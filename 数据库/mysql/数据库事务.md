# **开篇**

在数据库操作中，一项事务（Transaction）是由一条或多条操作数据库的 SQL 语句组成的一个不可分割的工作单元，这些操作要么都完成，要么都取消。接下来将围绕事务的特性、并发问题以及隔离级别进行讲解



# **四大特性**



事务的定义很严格，它必须同时满足四个特性，即原子性、一致性、隔离性和持久性，也就是人们俗称的 ACID 特性



## **原子性（Atomicity）**



　　原子性是指事务必须是一个不可分割的最小工作单元，包含的所有操作要么全部成功，要么全部失败回滚.



## **一致性（Consistency）**



　　原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见



## **隔离性（Isolation）**



　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。



## **持久性（Durability）**



　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作





# **并发问题**

在实际应用中，数据库中的数据是要被多个用户共同访问的，在多个用户同时操作相同的数据时，可能就会出现一些事务的并发问题，具体如下





## **脏读**

指一个事务读取到另一个事务未提交的数据



## **不可重复读**

指一个事务对同一行数据重复读取两次，但得到的结果不同，例如事务T1在读取某一数据，然后进行业务逻辑，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1业务逻辑处理完毕，准备提交事务但是读取到的数据不是第一次读取的数据，提交失败



## **虚读/幻读**

指一个事务执行两次查询，但第二次查询的结果包含了第一次查询中未出现的数据。例如T1 事务将所有状态改成 已完成，读取到数据一共有 100条， T2 事务写入了一条数据，T1 提交的时候发现数据多出来一条



# **隔离级别**



为了避免上述事务并发问题的出现，在标准的 SQL 规范中定义了四种事务隔离级别，不同的隔离级别对事务的处理有所不同。这四种事务的隔离级别如下



## **Serializable (串行化)**

可避免脏读、不可重复读、幻读的发生，原理就是每个事务都是串行化执行。



## **Repeatable read (可重复读)**

可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别



## **Read committed (读已提交)**

读提交，顾名思义，就是只能读到已经提交了的内容。这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别，可避免脏读的发生



## **Read uncommitted (读未提交)**

在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生“脏读”、“不可重复读”、“幻读”。最低级别，任何情况都无法保证

